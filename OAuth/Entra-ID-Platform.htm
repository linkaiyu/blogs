<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Entra ID Platform - MSAL & OAuth Reference</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, #0078d4, #106ebe);
            color: white;
            padding: 30px;
            border-radius: 10px;
            margin-bottom: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .main-content {
            display: flex;
            flex-direction: column;
            gap: 30px;
            min-height: 600px;
        }

        .table-section {
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .section-header {
            background: #f8f9fa;
            padding: 20px;
            border-bottom: 2px solid #e9ecef;
        }

        .section-header h2 {
            color: #0078d4;
            font-size: 1.5em;
        }

        .reference-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 14px;
        }

        .reference-table th {
            background: #0078d4;
            color: white;
            padding: 15px 10px;
            text-align: left;
            font-weight: 600;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .reference-table td {
            padding: 12px 10px;
            border-bottom: 1px solid #e9ecef;
            vertical-align: top;
        }

        .reference-table tr:hover {
            background-color: #f8f9fa;
        }

        .clickable-field {
            cursor: pointer;
            color: #0078d4;
            text-decoration: underline;
            transition: color 0.3s ease;
        }

        .clickable-field:hover {
            color: #106ebe;
            background-color: #e3f2fd;
            padding: 2px 4px;
            border-radius: 3px;
        }

        .show-all-btn {
            background: #28a745;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: background-color 0.3s ease;
        }

        .show-all-btn:hover {
            background: #218838;
        }

        .content-panel {
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            display: flex;
            flex-direction: column;
        }

        .content-header {
            background: #f8f9fa;
            padding: 20px;
            border-bottom: 2px solid #e9ecef;
        }

        .content-header h2 {
            color: #0078d4;
            font-size: 1.5em;
        }

        .content-display {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
            max-height: 600px;
        }

        .content-section {
            margin-bottom: 25px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e9ecef;
        }

        .content-section:last-child {
            border-bottom: none;
        }

        .content-section h3 {
            color: #0078d4;
            margin-bottom: 10px;
            font-size: 1.2em;
        }

        .content-section p {
            margin-bottom: 10px;
            text-align: justify;
        }

        .content-section ul {
            margin-left: 20px;
            margin-bottom: 10px;
        }

        .content-section li {
            margin-bottom: 5px;
        }

        .code-block {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            overflow-x: auto;
        }

        .link {
            color: #0078d4;
            text-decoration: none;
        }

        .link:hover {
            text-decoration: underline;
        }

        .table-container {
            overflow-x: auto;
            max-height: 600px;
            overflow-y: auto;
        }

        @media (max-width: 1200px) {
            .main-content {
                gap: 20px;
            }
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #6c757d;
            font-style: italic;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="main-content">
            <div class="table-section">
                <div class="table-container">
                    <table class="reference-table" id="referenceTable">
                        <thead>
                            <tr>
                                <th>MSAL App Type</th>
                                <th>Code Sample (.NET C#)</th>
                                <th>OAuth App Types</th>
                                <th>OAuth Flow</th>
                                <th>Sample Requests</th>
                                <th>Sample Response</th>
                                <th>Entra-ID Registration</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="tableBody">
                            <!-- Table content will be populated by JavaScript -->
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="content-panel">
                <div class="content-display" id="contentDisplay">
                    <div class="loading">
                        Click on any field in the cross-reference table to view detailed information here.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Content data structure - stores all information for each application type
        const contentData = {
            webApp: {
                msalAppType: {
                    title: "ASP.NET Web Application",
                    content: `ASP.NET Web Applications using MSAL.NET provide secure authentication and authorization for web-based applications. These applications run on a server and handle user authentication through web browsers.

Key characteristics:
• Server-side application that runs on IIS or similar web servers
• Uses confidential client credentials (client secret or certificate)
• Supports Authorization Code flow with PKCE
• Can maintain session state and cache tokens securely on the server
• Integrates with ASP.NET Core Identity for comprehensive user management

MSAL.NET provides robust support for web applications through the Microsoft.Identity.Web library, which simplifies integration with ASP.NET Core applications.`
                },
                codeSample: {
                    title: ".NET C# Code Sample - Web Application",
                    content: `Here's a complete example of implementing MSAL in an ASP.NET Core web application:

Startup Configuration:
\`\`\`csharp
public void ConfigureServices(IServiceCollection services)
{
    services.AddAuthentication(OpenIdConnectDefaults.AuthenticationScheme)
        .AddMicrosoftIdentityWebApp(Configuration.GetSection("AzureAd"));
    
    services.AddControllersWithViews(options =>
    {
        var policy = new AuthorizationPolicyBuilder()
            .RequireAuthenticatedUser()
            .Build();
        options.Filters.Add(new AuthorizeFilter(policy));
    });
}
\`\`\`

Controller Implementation:
\`\`\`csharp
[Authorize]
public class HomeController : Controller
{
    private readonly ITokenAcquisition _tokenAcquisition;

    public HomeController(ITokenAcquisition tokenAcquisition)
    {
        _tokenAcquisition = tokenAcquisition;
    }

    public async Task<IActionResult> CallApi()
    {
        string[] scopes = { "https://graph.microsoft.com/User.Read" };
        string accessToken = await _tokenAcquisition.GetAccessTokenForUserAsync(scopes);
        
        // Use the access token to call Microsoft Graph or other APIs
        return View();
    }
}
\`\`\`

Configuration (appsettings.json):
\`\`\`json
{
  "AzureAd": {
    "Instance": "https://login.microsoftonline.com/",
    "Domain": "your-tenant.onmicrosoft.com",
    "TenantId": "your-tenant-id",
    "ClientId": "your-client-id",
    "ClientSecret": "your-client-secret",
    "CallbackPath": "/signin-oidc"
  }
}
\`\`\`

GitHub Repository: https://github.com/Azure-Samples/active-directory-aspnetcore-webapp-openidconnect-v2`
                },
                oauthAppType: {
                    title: "Web Applications (OAuth 2.0)",
                    content: `Web applications in the OAuth 2.0 context are server-side applications that can securely store credentials and maintain session state.

Characteristics:
• Confidential clients that can authenticate securely with the authorization server
• Run on secure servers where client credentials can be protected
• Can receive authorization codes through redirect URIs
• Suitable for traditional web applications, server-side APIs, and web services

Security considerations:
• Must register redirect URIs that match exactly
• Should implement proper CSRF protection
• Can use client secrets or certificates for authentication
• Support for refresh tokens to maintain long-lived access

OAuth 2.0 defines web applications as confidential clients because they can protect their credentials from unauthorized access.`
                },
                oauthFlow: {
                    title: "Authorization Code Flow",
                    content: `The Authorization Code flow is the most secure OAuth 2.0 flow for web applications. It involves a two-step process that keeps access tokens away from the browser.

Flow Steps:
1. User is redirected to authorization server
2. User authenticates and consents to permissions
3. Authorization server redirects back with authorization code
4. Application exchanges code for access token (server-to-server)

Security Benefits:
• Access tokens never exposed to browser/user agent
• Client authentication required for token exchange
• Short-lived authorization codes reduce attack surface
• Supports refresh tokens for long-lived access

PKCE (Proof Key for Code Exchange) enhancement:
• Recommended even for confidential clients
• Provides additional protection against code interception
• Uses code_verifier and code_challenge parameters`
                },
                sampleRequest: {
                    title: "Sample HTTP Requests - Authorization Code Flow",
                    content: `Authorization Request:
\`\`\`http
GET https://login.microsoftonline.com/{tenant}/oauth2/v2.0/authorize?
client_id=your-client-id
&response_type=code
&redirect_uri=https://your-app.com/callback
&response_mode=query
&scope=openid%20profile%20User.Read
&state=12345
&code_challenge=dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
&code_challenge_method=S256
HTTP/1.1
Host: login.microsoftonline.com
\`\`\`

Token Exchange Request:
\`\`\`http
POST https://login.microsoftonline.com/{tenant}/oauth2/v2.0/token HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Host: login.microsoftonline.com

client_id=your-client-id
&scope=openid%20profile%20User.Read
&code=authorization-code-received
&redirect_uri=https://your-app.com/callback
&grant_type=authorization_code
&client_secret=your-client-secret
&code_verifier=dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
\`\`\`

Refresh Token Request:
\`\`\`http
POST https://login.microsoftonline.com/{tenant}/oauth2/v2.0/token HTTP/1.1
Content-Type: application/x-www-form-urlencoded

client_id=your-client-id
&scope=openid%20profile%20User.Read
&refresh_token=your-refresh-token
&grant_type=refresh_token
&client_secret=your-client-secret
\`\`\``
                },
                sampleResponse: {
                    title: "Sample HTTP Responses - Authorization Code Flow",
                    content: `Authorization Response (Success):
\`\`\`http
HTTP/1.1 302 Found
Location: https://your-app.com/callback?
code=M.R3_BAY.-CXnt6sF6mHZJuer9TgJmq9JwPf8Vn0VGM0
&state=12345
\`\`\`

Token Response (Success):
\`\`\`json
{
  "token_type": "Bearer",
  "scope": "openid profile User.Read",
  "expires_in": 3600,
  "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ik5HVEZ2ZEstZnl0aEV1Q...",
  "refresh_token": "AwABAAAAvPM1KaPlrEqdFSBzjqfTGDMxM4NzU3NjkxQ...",
  "id_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ik5HVEZ2ZEstZnl0aEV1Q..."
}
\`\`\`

Error Response:
\`\`\`json
{
  "error": "invalid_request",
  "error_description": "AADSTS70008: The provided authorization code is invalid or expired.",
  "error_codes": [70008],
  "timestamp": "2023-01-15 02:34:50Z",
  "trace_id": "66f1c038-e945-4669-9adc-553a007be2f3",
  "correlation_id": "66f1c038-e945-4669-9adc-553a007be2f3"
}
\`\`\``
                },
                entraIdRegistration: {
                    title: "Entra ID Registration - Web Application",
                    content: `Required Configuration in Azure Portal:

Application Registration:
• Application Type: Web
• Name: Your application display name
• Supported account types: Choose based on your requirements
  - Single tenant: Accounts in this organizational directory only
  - Multi-tenant: Accounts in any organizational directory
  - Multi-tenant + personal: Accounts in any directory + personal Microsoft accounts

Redirect URIs:
• Platform: Web
• Redirect URIs: https://your-app.com/signin-oidc (or your callback endpoint)
• Front-channel logout URL: https://your-app.com/signout-callback-oidc

Authentication Configuration:
• Access tokens: Not typically required for web apps
• ID tokens: Enable if using OpenID Connect
• Allow public client flows: No (keep disabled)

Client Secret:
• Generate a client secret from "Certificates & secrets"
• Store securely and rotate regularly
• Alternative: Use certificate-based authentication

API Permissions:
• Microsoft Graph permissions based on your requirements
• User.Read (typically granted by default)
• Additional scopes as needed for your application

Optional Configuration:
• Token configuration: Add optional claims if needed
• Branding: Configure application logo and terms of service URLs
• Single sign-on: Configure if using SAML or WS-Fed`
                }
            },
            
            desktopApp: {
                msalAppType: {
                    title: "Desktop Application",
                    content: `Desktop Applications using MSAL.NET provide secure authentication for client applications running on user devices such as Windows, macOS, or Linux systems.

Key characteristics:
• Public client applications that cannot securely store credentials
• Run on user's local machine with direct user interaction
• Support interactive authentication flows with embedded or system browsers
• Can cache tokens locally for improved user experience
• Suitable for WPF, WinForms, UWP, and cross-platform applications

MSAL.NET provides comprehensive support for desktop applications through the PublicClientApplication class, enabling secure token acquisition and management for native applications.`
                },
                codeSample: {
                    title: ".NET C# Code Sample - Desktop Application",
                    content: `Complete implementation of MSAL in a desktop application:

Application Setup:
\`\`\`csharp
using Microsoft.Identity.Client;

public class AuthenticationService
{
    private static readonly string ClientId = "your-client-id";
    private static readonly string Authority = "https://login.microsoftonline.com/your-tenant-id";
    private static readonly string[] Scopes = { "User.Read" };
    
    private readonly IPublicClientApplication _app;

    public AuthenticationService()
    {
        _app = PublicClientApplicationBuilder
            .Create(ClientId)
            .WithAuthority(Authority)
            .WithRedirectUri("http://localhost")
            .WithLogging(LogLevel.Info)
            .Build();
    }
}
\`\`\`

Interactive Token Acquisition:
\`\`\`csharp
public async Task<AuthenticationResult> SignInAsync()
{
    try
    {
        // Try to get token silently first
        var accounts = await _app.GetAccountsAsync();
        var firstAccount = accounts.FirstOrDefault();
        
        if (firstAccount != null)
        {
            var result = await _app.AcquireTokenSilent(Scopes, firstAccount)
                .ExecuteAsync();
            return result;
        }
    }
    catch (MsalUiRequiredException)
    {
        // Silent acquisition failed, fall back to interactive
    }

    // Interactive token acquisition
    return await _app.AcquireTokenInteractive(Scopes)
        .WithPrompt(Prompt.SelectAccount)
        .ExecuteAsync();
}
\`\`\`

Token Cache Management:
\`\`\`csharp
public async Task<string> GetAccessTokenAsync()
{
    var accounts = await _app.GetAccountsAsync();
    var firstAccount = accounts.FirstOrDefault();

    if (firstAccount == null)
        throw new InvalidOperationException("No user signed in");

    var result = await _app.AcquireTokenSilent(Scopes, firstAccount)
        .ExecuteAsync();
    
    return result.AccessToken;
}

public async Task SignOutAsync()
{
    var accounts = await _app.GetAccountsAsync();
    
    foreach (var account in accounts)
    {
        await _app.RemoveAsync(account);
    }
}
\`\`\`

GitHub Repository: https://github.com/Azure-Samples/active-directory-dotnet-desktop-msgraph-v2`
                },
                oauthAppType: {
                    title: "Native Applications (OAuth 2.0)",
                    content: `Native applications in OAuth 2.0 are public clients that run on user devices and cannot securely store credentials.

Characteristics:
• Public clients - cannot protect client secrets
• Run directly on user's device (desktop, mobile)
• Use system browsers or embedded web views for authentication
• Redirect URIs typically use custom schemes or localhost
• Cannot authenticate with authorization server using client credentials

Security considerations:
• Must use PKCE (Proof Key for Code Exchange) for security
• Cannot store client secrets securely
• Vulnerable to credential extraction from the application
• Should use system browsers when possible for better security
• Token storage should use platform-specific secure storage

OAuth 2.0 treats native applications as public clients due to their inability to maintain confidentiality of credentials.`
                },
                oauthFlow: {
                    title: "Authorization Code Flow with PKCE",
                    content: `The Authorization Code flow with PKCE (Proof Key for Code Exchange) is the recommended flow for native applications, providing security against code interception attacks.

PKCE Enhancement:
• Generates a cryptographically random code_verifier
• Creates code_challenge using SHA256 hash of code_verifier
• Protects against authorization code interception attacks
• Required for public clients (native/mobile apps)

Flow Steps:
1. Generate code_verifier and code_challenge
2. Redirect user to authorization endpoint with code_challenge
3. User authenticates and grants consent
4. Receive authorization code at redirect URI
5. Exchange code for tokens using code_verifier

Security Benefits:
• Mitigates authorization code interception attacks
• No client secret required
• Works with custom URI schemes and localhost redirects
• Recommended by OAuth 2.0 Security Best Practices`
                },
                sampleRequest: {
                    title: "Sample HTTP Requests - Authorization Code Flow with PKCE",
                    content: `Authorization Request with PKCE:
\`\`\`http
GET https://login.microsoftonline.com/{tenant}/oauth2/v2.0/authorize?
client_id=your-client-id
&response_type=code
&redirect_uri=myapp://authenticated
&response_mode=query
&scope=openid%20profile%20User.Read
&state=12345
&code_challenge=dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
&code_challenge_method=S256
HTTP/1.1
Host: login.microsoftonline.com
\`\`\`

Token Exchange Request:
\`\`\`http
POST https://login.microsoftonline.com/{tenant}/oauth2/v2.0/token HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Host: login.microsoftonline.com

client_id=your-client-id
&scope=openid%20profile%20User.Read
&code=authorization-code-received
&redirect_uri=myapp://authenticated
&grant_type=authorization_code
&code_verifier=dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk
\`\`\`

Note: No client_secret parameter is included because native apps are public clients.

Silent Token Request:
\`\`\`http
POST https://login.microsoftonline.com/{tenant}/oauth2/v2.0/token HTTP/1.1
Content-Type: application/x-www-form-urlencoded

client_id=your-client-id
&scope=openid%20profile%20User.Read
&refresh_token=your-refresh-token
&grant_type=refresh_token
\`\`\``
                },
                sampleResponse: {
                    title: "Sample HTTP Responses - Desktop Application",
                    content: `Authorization Response (Success):
\`\`\`http
HTTP/1.1 302 Found
Location: myapp://authenticated?
code=M.R3_BAY.-CXnt6sF6mHZJuer9TgJmq9JwPf8Vn0VGM0
&state=12345
\`\`\`

Token Response (Success):
\`\`\`json
{
  "token_type": "Bearer",
  "scope": "openid profile User.Read",
  "expires_in": 3600,
  "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ik5HVEZ2ZEstZnl0aEV1Q...",
  "refresh_token": "AwABAAAAvPM1KaPlrEqdFSBzjqfTGDMxM4NzU3NjkxQ...",
  "id_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ik5HVEZ2ZEstZnl0aEV1Q..."
}
\`\`\`

Error Response (PKCE Verification Failed):
\`\`\`json
{
  "error": "invalid_grant",
  "error_description": "AADSTS70023: The code_verifier does not match the code_challenge associated with the authorization code.",
  "error_codes": [70023],
  "timestamp": "2023-01-15 02:34:50Z",
  "trace_id": "66f1c038-e945-4669-9adc-553a007be2f3",
  "correlation_id": "66f1c038-e945-4669-9adc-553a007be2f3"
}
\`\`\``
                },
                entraIdRegistration: {
                    title: "Entra ID Registration - Desktop Application",
                    content: `Required Configuration in Azure Portal:

Application Registration:
• Application Type: Public client/native
• Name: Your desktop application name
• Supported account types: Choose appropriate option
  - Single tenant: For enterprise applications
  - Multi-tenant: For applications used across organizations
  - Multi-tenant + personal: Include personal Microsoft accounts

Redirect URIs:
• Platform: Mobile and desktop applications
• Redirect URIs: 
  - Custom scheme: myapp://authenticated
  - Localhost: http://localhost:8080 (for testing)
  - MSAL default: msal{client-id}://auth

Authentication Configuration:
• Access tokens: Not required for public clients
• ID tokens: Enable if using OpenID Connect
• Allow public client flows: Yes (required for desktop apps)
• Default client type: Public client

Client Secret:
• Not applicable for desktop applications
• Desktop apps are public clients and cannot securely store secrets
• Use PKCE instead for security

API Permissions:
• Microsoft Graph permissions as required
• User.Read (typically sufficient for basic scenarios)
• Delegated permissions only (no application permissions for public clients)

Advanced Settings:
• Token configuration: Configure optional claims if needed
• Authentication flows: Enable Authorization Code with PKCE
• Supported account types: Configure based on target audience`
                }
            },

            daemonApp: {
                msalAppType: {
                    title: "Daemon/Service Application",
                    content: `Daemon Applications using MSAL.NET are background services or applications that run without user interaction and authenticate using their own identity rather than a user's identity.

Key characteristics:
• Confidential client applications with secure credential storage
• Run as background services, scheduled tasks, or server processes
• Use application permissions instead of delegated permissions
• Authenticate using client credentials (secret or certificate)
• No user interaction or consent required during runtime
• Suitable for data synchronization, batch processing, and automated workflows

MSAL.NET provides support for daemon applications through the ConfidentialClientApplication class with client credential flows.`
                },
                codeSample: {
                    title: ".NET C# Code Sample - Daemon Application",
                    content: `Complete implementation of MSAL in a daemon/service application:

Application Setup with Client Secret:
\`\`\`csharp
using Microsoft.Identity.Client;

public class DaemonService
{
    private static readonly string ClientId = "your-client-id";
    private static readonly string ClientSecret = "your-client-secret";
    private static readonly string Authority = "https://login.microsoftonline.com/your-tenant-id";
    private static readonly string[] Scopes = { "https://graph.microsoft.com/.default" };
    
    private readonly IConfidentialClientApplication _app;

    public DaemonService()
    {
        _app = ConfidentialClientApplicationBuilder
            .Create(ClientId)
            .WithClientSecret(ClientSecret)
            .WithAuthority(Authority)
            .Build();
    }
}
\`\`\`

Alternative Setup with Certificate:
\`\`\`csharp
public DaemonService()
{
    var certificate = LoadCertificateFromStore("thumbprint");
    
    _app = ConfidentialClientApplicationBuilder
        .Create(ClientId)
        .WithCertificate(certificate)
        .WithAuthority(Authority)
        .Build();
}

private X509Certificate2 LoadCertificateFromStore(string thumbprint)
{
    using (var store = new X509Store(StoreName.My, StoreLocation.CurrentUser))
    {
        store.Open(OpenFlags.ReadOnly);
        var certificates = store.Certificates.Find(
            X509FindType.FindByThumbprint, thumbprint, false);
        
        if (certificates.Count == 0)
            throw new InvalidOperationException($"Certificate with thumbprint {thumbprint} not found");
            
        return certificates[0];
    }
}
\`\`\`

Token Acquisition:
\`\`\`csharp
public async Task<string> GetAccessTokenAsync()
{
    try
    {
        var result = await _app.AcquireTokenForClient(Scopes)
            .ExecuteAsync();
        
        return result.AccessToken;
    }
    catch (MsalServiceException ex)
    {
        // Handle authentication errors
        Console.WriteLine($"Error acquiring token: {ex.Message}");
        throw;
    }
}
\`\`\`

Using the Token:
\`\`\`csharp
public async Task CallMicrosoftGraphAsync()
{
    var accessToken = await GetAccessTokenAsync();
    
    using (var httpClient = new HttpClient())
    {
        httpClient.DefaultRequestHeaders.Authorization = 
            new System.Net.Http.Headers.AuthenticationHeaderValue("Bearer", accessToken);
        
        var response = await httpClient.GetAsync("https://graph.microsoft.com/v1.0/users");
        var content = await response.Content.ReadAsStringAsync();
        
        // Process the response
        Console.WriteLine(content);
    }
}
\`\`\`

GitHub Repository: https://github.com/Azure-Samples/active-directory-dotnetcore-daemon-v2`
                },
                oauthAppType: {
                    title: "Service/Daemon Applications (OAuth 2.0)",
                    content: `Service or daemon applications in OAuth 2.0 are confidential clients that operate without user interaction and authenticate using their own credentials.

Characteristics:
• Confidential clients that can securely store credentials
• Operate autonomously without user interaction
• Use application permissions instead of delegated permissions
• Authenticate using client credentials (secret or certificate)
• Typically run as background services, APIs, or scheduled jobs

Security considerations:
• Must securely store and protect client credentials
• Should use certificate-based authentication when possible
• Requires admin consent for application permissions
• Should implement proper credential rotation policies
• Access is granted to the application itself, not on behalf of users

Use cases:
• Data synchronization between systems
• Batch processing and automated workflows
• Monitoring and reporting services
• API-to-API communication without user context`
                },
                oauthFlow: {
                    title: "Client Credentials Flow",
                    content: `The Client Credentials flow is designed for machine-to-machine authentication where the application acts on its own behalf rather than on behalf of a user.

Flow Characteristics:
• Simplest OAuth 2.0 flow - direct token request
• No user interaction or consent required
• Application authenticates using its own credentials
• Results in application-only access tokens
• Suitable for server-to-server communication

Flow Steps:
1. Application authenticates with authorization server using client credentials
2. Authorization server validates credentials
3. Authorization server returns access token
4. Application uses access token to access protected resources

Security Requirements:
• Client credentials must be securely stored
• Certificate-based authentication is preferred over client secrets
• Regular credential rotation is recommended
• Scope is limited to application permissions only`
                },
                sampleRequest: {
                    title: "Sample HTTP Requests - Client Credentials Flow",
                    content: `Token Request with Client Secret:
\`\`\`http
POST https://login.microsoftonline.com/{tenant}/oauth2/v2.0/token HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Host: login.microsoftonline.com

client_id=your-client-id
&scope=https://graph.microsoft.com/.default
&client_secret=your-client-secret
&grant_type=client_credentials
\`\`\`

Token Request with Client Certificate:
\`\`\`http
POST https://login.microsoftonline.com/{tenant}/oauth2/v2.0/token HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Host: login.microsoftonline.com

client_id=your-client-id
&scope=https://graph.microsoft.com/.default
&client_assertion_type=urn:ietf:params:oauth:client-assertion-type:jwt-bearer
&client_assertion=eyJhbGciOiJSUzI1NiIsIng1dCI6Imd4OHRHeXN5amNScUtqRlBuZDdSRnd2d1pJMCJ9...
&grant_type=client_credentials
\`\`\`

API Call with Access Token:
\`\`\`http
GET https://graph.microsoft.com/v1.0/users HTTP/1.1
Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ik5HVEZ2ZEstZnl0aEV1Q...
Host: graph.microsoft.com
\`\`\``
                },
                sampleResponse: {
                    title: "Sample HTTP Responses - Client Credentials Flow",
                    content: `Token Response (Success):
\`\`\`json
{
  "token_type": "Bearer",
  "expires_in": 3600,
  "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ik5HVEZ2ZEstZnl0aEV1Q...",
  "scope": "https://graph.microsoft.com/.default"
}
\`\`\`

Note: No refresh_token is provided in client credentials flow as the application can always request a new token using its credentials.

Error Response (Invalid Client):
\`\`\`json
{
  "error": "invalid_client",
  "error_description": "AADSTS70002: The request body must contain the following parameter: 'client_secret or client_assertion'.",
  "error_codes": [70002],
  "timestamp": "2023-01-15 02:34:50Z",
  "trace_id": "66f1c038-e945-4669-9adc-553a007be2f3",
  "correlation_id": "66f1c038-e945-4669-9adc-553a007be2f3"
}
\`\`\`

Error Response (Insufficient Privileges):
\`\`\`json
{
  "error": "insufficient_privileges",
  "error_description": "AADSTS50013: Assertion failed signature validation. [Reason - The key was not found.]",
  "error_codes": [50013],
  "timestamp": "2023-01-15 02:34:50Z",
  "trace_id": "66f1c038-e945-4669-9adc-553a007be2f3",
  "correlation_id": "66f1c038-e945-4669-9adc-553a007be2f3"
}
\`\`\``
                },
                entraIdRegistration: {
                    title: "Entra ID Registration - Daemon Application",
                    content: `Required Configuration in Azure Portal:

Application Registration:
• Application Type: Web (for daemon apps)
• Name: Your daemon service name
• Supported account types: Single tenant (recommended for daemon apps)
  - Accounts in this organizational directory only

Redirect URIs:
• Not required for daemon applications
• Client credentials flow doesn't use redirect URIs

Authentication Configuration:
• Access tokens: Not applicable
• ID tokens: Not applicable
• Allow public client flows: No (keep disabled)
• Client type: Confidential

Client Credentials:
Option 1 - Client Secret:
• Generate from "Certificates & secrets" section
• Store securely in configuration or key vault
• Set expiration and plan for rotation

Option 2 - Certificate (Recommended):
• Upload public certificate or generate certificate
• Store private key securely
• Better security than client secrets

API Permissions:
• Application permissions (not delegated permissions)
• Common Graph permissions for daemon apps:
  - User.Read.All (read all users)
  - Group.Read.All (read all groups)
  - Directory.Read.All (read directory data)
• Requires admin consent for application permissions

Grant Admin Consent:
• Required step for all application permissions
• Can be done during registration or separately
• Ensures the daemon app has necessary permissions

Security Recommendations:
• Use certificates instead of client secrets when possible
• Implement credential rotation policies
• Limit permissions to minimum required scope
• Use Azure Key Vault for credential storage`
                }
            },

            apiService: {
                msalAppType: {
                    title: "ASP.NET Web API Service",
                    content: `ASP.NET Web API Services using MSAL.NET provide secure backend services that can validate access tokens and call downstream APIs on behalf of users or applications.

Key characteristics:
• Protected web APIs that validate incoming access tokens
• Can act as both resource server and client
• Support both user-delegated and application-only scenarios
• Can call downstream APIs using on-behalf-of flow
• Integrate with ASP.NET Core authorization policies
• Support for token validation and scope-based authorization

MSAL.NET enables Web APIs to securely validate tokens from Microsoft identity platform and acquire tokens for downstream API calls using the Microsoft.Identity.Web library.`
                },
                codeSample: {
                    title: ".NET C# Code Sample - Web API Service",
                    content: `Complete implementation of a protected Web API with downstream API calls:

Startup Configuration:
\`\`\`csharp
public void ConfigureServices(IServiceCollection services)
{
    // Add authentication
    services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
        .AddMicrosoftIdentityWebApi(Configuration.GetSection("AzureAd"))
        .EnableTokenAcquisitionToCallDownstreamApi()
        .AddMicrosoftGraph(Configuration.GetSection("MicrosoftGraph"))
        .AddInMemoryTokenCaches();

    services.AddControllers();
    services.AddAuthorization();
}

public void Configure(IApplicationBuilder app, IWebHostEnvironment env)
{
    app.UseAuthentication();
    app.UseAuthorization();
    app.UseRouting();
    app.UseEndpoints(endpoints => endpoints.MapControllers());
}
\`\`\`

Protected API Controller:
\`\`\`csharp
[Authorize]
[ApiController]
[Route("api/[controller]")]
public class WeatherController : ControllerBase
{
    private readonly ITokenAcquisition _tokenAcquisition;
    private readonly GraphServiceClient _graphClient;

    public WeatherController(ITokenAcquisition tokenAcquisition, 
                           GraphServiceClient graphClient)
    {
        _tokenAcquisition = tokenAcquisition;
        _graphClient = graphClient;
    }

    [HttpGet]
    [RequiredScope("Weather.Read")]
    public async Task<IActionResult> Get()
    {
        // This API endpoint requires Weather.Read scope
        var weatherData = GetWeatherData();
        return Ok(weatherData);
    }

    [HttpGet("profile")]
    [RequiredScope("Weather.Read")]
    public async Task<IActionResult> GetUserProfile()
    {
        try
        {
            // Call Microsoft Graph on behalf of the user
            var user = await _graphClient.Me.Request().GetAsync();
            return Ok(new { user.DisplayName, user.Mail });
        }
        catch (ServiceException ex)
        {
            return BadRequest($"Error calling Graph API: {ex.Message}");
        }
    }

    [HttpGet("downstream")]
    [RequiredScope("Weather.Read")]
    public async Task<IActionResult> CallDownstreamApi()
    {
        try
        {
            // Get token for downstream API
            string[] scopes = { "https://api.contoso.com/user_impersonation" };
            var accessToken = await _tokenAcquisition.GetAccessTokenForUserAsync(scopes);

            // Call downstream API
            using var httpClient = new HttpClient();
            httpClient.DefaultRequestHeaders.Authorization = 
                new AuthenticationHeaderValue("Bearer", accessToken);
            
            var response = await httpClient.GetAsync("https://api.contoso.com/data");
            var content = await response.Content.ReadAsStringAsync();
            
            return Ok(content);
        }
        catch (MsalUiRequiredException)
        {
            return Challenge(); // Requires user interaction
        }
    }
}
\`\`\`

Configuration (appsettings.json):
\`\`\`json
{
  "AzureAd": {
    "Instance": "https://login.microsoftonline.com/",
    "Domain": "your-tenant.onmicrosoft.com",
    "TenantId": "your-tenant-id",
    "ClientId": "your-api-client-id",
    "ClientSecret": "your-api-client-secret"
  },
  "MicrosoftGraph": {
    "BaseUrl": "https://graph.microsoft.com/v1.0",
    "Scopes": "User.Read"
  }
}
\`\`\`

GitHub Repository: https://github.com/Azure-Samples/active-directory-aspnetcore-webapp-openidconnect-v2/tree/master/4-WebApp-your-API`
                },
                oauthAppType: {
                    title: "Protected Resources/APIs (OAuth 2.0)",
                    content: `Protected resources or APIs in OAuth 2.0 are services that accept and validate access tokens to provide secure access to protected data and functionality.

Characteristics:
• Resource servers that protect APIs and data
• Validate access tokens issued by authorization servers
• Enforce scope-based authorization
• Can accept tokens from multiple client types
• May act as clients themselves when calling other APIs
• Support both delegated and application permissions

Token Validation:
• Verify token signature using issuer's public keys
• Validate token expiration and not-before claims
• Check audience (aud) claim matches the API
• Verify issuer (iss) claim is trusted
• Validate scope claims for authorization

Authorization Patterns:
• Scope-based access control
• Role-based access control (RBAC)
• Attribute-based access control (ABAC)
• Resource-level permissions
• User context preservation for downstream calls`
                },
                oauthFlow: {
                    title: "On-Behalf-Of (OBO) Flow",
                    content: `The On-Behalf-Of flow enables a Web API to call another downstream API on behalf of the user who originally authenticated with the client application.

Flow Purpose:
• Preserve user context through API call chains
• Enable secure API-to-API communication
• Maintain user consent and permissions
• Support complex multi-tier architectures

Flow Steps:
1. Client gets access token for Web API A
2. Client calls Web API A with access token
3. Web API A validates the incoming token
4. Web API A exchanges the token for a new token to call Web API B
5. Web API A calls Web API B with the new token

Security Benefits:
• User context is maintained throughout the call chain
• Each API can enforce its own authorization policies
• Granular permission control at each tier
• Audit trail preserves user identity
• No shared secrets between APIs needed

Requirements:
• Original token must have appropriate scopes
• APIs must be properly registered and configured
• User consent for downstream API access may be required`
                },
                sampleRequest: {
                    title: "Sample HTTP Requests - On-Behalf-Of Flow",
                    content: `Client Calling Protected API:
\`\`\`http
GET https://api.contoso.com/weatherforecast HTTP/1.1
Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6Ik5HVEZ2ZEstZnl0aEV1Q...
Host: api.contoso.com
\`\`\`

Web API A Calling Web API B (OBO Token Exchange):
\`\`\`http
POST https://login.microsoftonline.com/{tenant}/oauth2/v2.0/token HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Host: login.microsoftonline.com

client_id=api-a-client-id
&client_secret=api-a-client-secret
&scope=https://api-b.contoso.com/user_impersonation
&assertion=eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI...
&grant_type=urn:ietf:params:oauth:grant-type:jwt-bearer
&requested_token_use=on_behalf_of
\`\`\`

Web API A Calling Web API B with OBO Token:
\`\`\`http
GET https://api-b.contoso.com/data HTTP/1.1
Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6ImRDbEFxWXpJNjJHYWx...
Host: api-b.contoso.com
\`\`\`

Alternative: Using Client Credentials for App-Only Access:
\`\`\`http
POST https://login.microsoftonline.com/{tenant}/oauth2/v2.0/token HTTP/1.1
Content-Type: application/x-www-form-urlencoded

client_id=api-a-client-id
&client_secret=api-a-client-secret
&scope=https://api-b.contoso.com/.default
&grant_type=client_credentials
\`\`\``
                },
                sampleResponse: {
                    title: "Sample HTTP Responses - Web API Service",
                    content: `Protected API Response (Success):
\`\`\`json
{
  "data": [
    {
      "date": "2023-01-16",
      "temperatureC": 25,
      "temperatureF": 77,
      "summary": "Warm"
    }
  ],
  "user": "john.doe@contoso.com"
}
\`\`\`

OBO Token Exchange Response (Success):
\`\`\`json
{
  "token_type": "Bearer",
  "scope": "https://api-b.contoso.com/user_impersonation",
  "expires_in": 3600,
  "access_token": "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiIsIng1dCI6ImRDbEFxWXpJNjJHYWx...",
  "refresh_token": "AwABAAAAvPM1KaPlrEqdFSBzjqfTGDMxM4NzU3NjkxQ..."
}
\`\`\`

Unauthorized Response (Invalid Token):
\`\`\`json
{
  "error": "invalid_token",
  "error_description": "The access token is invalid or expired.",
  "status": 401
}
\`\`\`

Forbidden Response (Insufficient Scope):
\`\`\`json
{
  "error": "insufficient_scope",
  "error_description": "The token does not have the required scope 'Weather.Read'.",
  "status": 403
}
\`\`\`

OBO Error Response (Interaction Required):
\`\`\`json
{
  "error": "interaction_required",
  "error_description": "AADSTS50076: Due to a configuration change made by your administrator, you must use multi-factor authentication.",
  "error_codes": [50076],
  "timestamp": "2023-01-15 02:34:50Z",
  "trace_id": "66f1c038-e945-4669-9adc-553a007be2f3",
  "correlation_id": "66f1c038-e945-4669-9adc-553a007be2f3",
  "suberror": "basic_action"
}
\`\`\``
                },
                entraIdRegistration: {
                    title: "Entra ID Registration - Web API Service",
                    content: `Required Configuration in Azure Portal:

Web API Registration:
• Application Type: Web
• Name: Your API service name
• Supported account types: Configure based on your requirements
  - Single tenant: For internal APIs
  - Multi-tenant: For APIs used by external applications

API Configuration:
• Application ID URI: Set a unique identifier (e.g., api://your-api-id)
• Scopes: Define custom scopes for your API
  - Weather.Read, Weather.Write (example scopes)
  - Configure admin consent requirements
• Roles: Define application roles if using RBAC

Authentication Configuration:
• Access tokens: Enable for API scenarios
• ID tokens: Usually not required for APIs
• Allow public client flows: No (keep disabled)

Client Credentials (for downstream calls):
• Client Secret: Generate if API needs to call other APIs
• Certificate: Alternative to client secret for better security

API Permissions (for downstream calls):
• Microsoft Graph permissions if calling Graph API
• Custom API permissions for other downstream APIs
• Use delegated permissions for OBO scenarios
• Use application permissions for app-only scenarios

Expose an API:
• Application ID URI: Must be set for custom APIs
• Scopes: Define what operations clients can perform
  - Name: Weather.Read
  - Display name: Read weather data
  - Description: Allows reading weather information
  - Admin consent: Configure as needed

Authorized Client Applications:
• Pre-authorize trusted client applications
• Avoids consent prompts for known clients
• Specify client IDs and authorized scopes

Token Configuration:
• Optional claims: Add custom claims to tokens
• Group claims: Include user group memberships
• Role claims: Include application role assignments

Manifest Configuration (Advanced):
• accessTokenAcceptedVersion: Set to 2 for v2.0 tokens
• signInAudience: Configure supported account types
• requiredResourceAccess: Define required permissions`
                }
            }
        };

        // Table data structure
        const tableData = [
            {
                key: 'webApp',
                msalAppType: 'ASP.NET Web Application',
                codeSample: 'Microsoft.Identity.Web Sample',
                oauthAppType: 'Web Applications',
                oauthFlow: 'Authorization Code Flow',
                sampleRequest: 'Authorization Code Requests',
                sampleResponse: 'Token & Error Responses',
                entraIdRegistration: 'Web App Registration'
            },
            {
                key: 'desktopApp',
                msalAppType: 'Desktop Application',
                codeSample: 'PublicClientApplication Sample',
                oauthAppType: 'Native Applications',
                oauthFlow: 'Authorization Code + PKCE',
                sampleRequest: 'PKCE Flow Requests',
                sampleResponse: 'Desktop App Responses',
                entraIdRegistration: 'Desktop App Registration'
            },
            {
                key: 'daemonApp',
                msalAppType: 'Daemon/Service Application',
                codeSample: 'ConfidentialClientApplication Sample',
                oauthAppType: 'Service/Daemon Applications',
                oauthFlow: 'Client Credentials Flow',
                sampleRequest: 'Client Credentials Requests',
                sampleResponse: 'Service App Responses',
                entraIdRegistration: 'Daemon App Registration'
            },
            {
                key: 'apiService',
                msalAppType: 'ASP.NET Web API Service',
                codeSample: 'Protected API Sample',
                oauthAppType: 'Protected Resources/APIs',
                oauthFlow: 'On-Behalf-Of (OBO) Flow',
                sampleRequest: 'OBO Flow Requests',
                sampleResponse: 'API Service Responses',
                entraIdRegistration: 'Web API Registration'
            }
        ];

        // DOM elements
        const tableBody = document.getElementById('tableBody');
        const contentDisplay = document.getElementById('contentDisplay');

        // Populate table
        function populateTable() {
            tableBody.innerHTML = '';
            
            tableData.forEach(row => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td><span class="clickable-field" data-type="msalAppType" data-key="${row.key}">${row.msalAppType}</span></td>
                    <td><span class="clickable-field" data-type="codeSample" data-key="${row.key}">${row.codeSample}</span></td>
                    <td><span class="clickable-field" data-type="oauthAppType" data-key="${row.key}">${row.oauthAppType}</span></td>
                    <td><span class="clickable-field" data-type="oauthFlow" data-key="${row.key}">${row.oauthFlow}</span></td>
                    <td><span class="clickable-field" data-type="sampleRequest" data-key="${row.key}">${row.sampleRequest}</span></td>
                    <td><span class="clickable-field" data-type="sampleResponse" data-key="${row.key}">${row.sampleResponse}</span></td>
                    <td><span class="clickable-field" data-type="entraIdRegistration" data-key="${row.key}">${row.entraIdRegistration}</span></td>
                    <td><button class="show-all-btn" data-key="${row.key}">Show All</button></td>
                `;
                tableBody.appendChild(tr);
            });
        }

        // Display content function
        function displayContent(type, key, showAll = false) {
            const data = contentData[key];
            if (!data) return;

            let html = '';

            if (showAll) {
                // Show all content for the row
                html += `<div class="content-section">
                    <h3>${data[type].title}</h3>
                    <p>${data[type].content.replace(/\n/g, '</p><p>')}</p>
                </div>`;

                // Add all other sections
                Object.keys(data).forEach(sectionKey => {
                    if (sectionKey !== type) {
                        const section = data[sectionKey];
                        html += `<div class="content-section">
                            <h3>${section.title}</h3>
                            <p>${formatContent(section.content)}</p>
                        </div>`;
                    }
                });
            } else {
                // Show only the clicked section
                const section = data[type];
                html = `<div class="content-section">
                    <h3>${section.title}</h3>
                    <p>${formatContent(section.content)}</p>
                </div>`;
            }

            contentDisplay.innerHTML = html;
        }

        // Format content with code blocks and links
        function formatContent(content) {
            return content
                .replace(/\n/g, '</p><p>')
                .replace(/```(\w+)?\n([\s\S]*?)```/g, '<div class="code-block">$2</div>')
                .replace(/`([^`]+)`/g, '<code>$1</code>')
                .replace(/https?:\/\/[^\s)]+/g, '<a href="$&" class="link" target="_blank">$&</a>');
        }

        // Event listeners
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('clickable-field')) {
                const type = e.target.getAttribute('data-type');
                const key = e.target.getAttribute('data-key');
                displayContent(type, key, false);
            } else if (e.target.classList.contains('show-all-btn')) {
                const key = e.target.getAttribute('data-key');
                // Use the first field type as the primary content
                displayContent('msalAppType', key, true);
            }
        });

        // Initialize table
        populateTable();
    </script>
</body>
</html>
